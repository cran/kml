# include "kml.h"

#define both_FINITE(a,b) (R_FINITE(a) && R_FINITE(b))
#define both_non_NA(a,b) (!ISNAN(a) && !ISNAN(b))

static double R_manhattan2(double *x,double *y,int taille){
    double dev, dist;
    int count, i;

    count = 0;
    dist = 0;
    for(i = 0 ; i < taille ; i++) {
	if(both_non_NA(x[i], y[i])) {
	    dev = fabs(x[i] - y[i]);
	    if(!ISNAN(dev)) {
		dist += dev;
		count++;
	    }
	}
    }
    if(count == 0) return NA_REAL;
    if(count != taille) dist /= ((double)count/taille);
    return dist;
};

static double R_euclidean2(double *x, double *y, int taille)
{
    double dev, dist;
    int count, i;

    count= 0;
    dist = 0;
    for(i = 0 ; i < taille ; i++) {
	if(both_non_NA(x[i], y[i])) {
	    dev = (x[i] - y[i]);
	    if(!ISNAN(dev)) {
		dist += dev * dev;
		count++;
	    }
	}
    }
    if(count == 0)return NA_REAL;
    if(count != taille) dist /= ((double)count/taille);
    return sqrt(dist);
}

static double R_minkowski2(double *x,double *y,int taille,double power){
    double dev, dist;
    int count, i;

    count= 0;
    dist = 0;
    for(i = 0 ; i < taille ; i++) {
	if(both_non_NA(x[i], y[i])) {
	    dev = (x[i] - y[i]);
	    if(!ISNAN(dev)) {
		dist += R_pow(fabs(dev), power);
		count++;
	    }
	}
    }
    if(count == 0) return NA_REAL;
    if(count != taille) dist /= ((double)count/taille);
    return R_pow(dist, 1.0/power);
};


static double R_maximum2(double *x,double *y,int taille){
    double dev, dist;
    int count, i;

    count = 0;
    dist = -DBL_MAX;
    for(i = 0 ; i < taille ; i++) {
	if(both_non_NA(x[i], y[i])) {
	    dev = fabs(x[i] - y[i]);
	    if(!ISNAN(dev)) {
		if(dev > dist)
		    dist = dev;
		count++;
	    }
	}
    }
    if(count == 0) return NA_REAL;
    return dist;
};


static double R_canberra2(double *x,double *y,int taille){
    double dev, dist, sum, diff;
    int count, i;

    count = 0;
    dist = 0;
    for(i = 0 ; i < taille ; i++) {
	if(both_non_NA(x[i], y[i])) {
	    sum = fabs(x[i] + y[i]);
	    diff = fabs(x[i] - y[i]);
	    if (sum > DBL_MIN || diff > DBL_MIN) {
		dev = diff/sum;
		if(!ISNAN(dev) ||
		   (!R_FINITE(diff) && diff == sum &&
		    /* use Inf = lim x -> oo */ (dev = 1.))) {
		    dist += dev;
		    count++;
		}
	    }
	}
    }
    if(count == 0) return NA_REAL;
    if(count != taille) dist /= ((double)count/taille);
    return dist;
};


static double R_dist_binary2(double *x,double *y,int taille){
    int total, count, dist;
    int i;

    total = 0;
    count = 0;
    dist = 0;

    for(i = 0 ; i < taille ; i++) {
	if(both_non_NA(x[i], y[i])) {
	    if(!both_FINITE(x[i], y[i])) {
		warning(("treating non-finite values as NA"));
	    }
	    else {
		if(x[i] || y[i]) {
		    count++;
		    if( ! (x[i] && y[i]) ) dist++;
		}
		total++;
	    }
	}
    }

    if(total == 0) return NA_REAL;
    if(count == 0) return 0;
    return (double) dist / count;

};


enum { MANHATTAN=1, EUCLIDEAN, MINKOWSKI, MAXIMUM,  CANBERRA, BINARY };
/* == 1,2,..., defined by order in the R function dist */

void R_distance2(double *x, double *y, int *taille, int *method, double *power, double *dist)
{
    switch(*method) {
    case MANHATTAN:
	*dist = R_manhattan2(x,y,*taille);
	break;
    case EUCLIDEAN:
	*dist = R_euclidean2(x,y,*taille);
	break;
    case MINKOWSKI:
	*dist = R_minkowski2(x,y,*taille,*power);
	break;
    case MAXIMUM:
	*dist = R_maximum2(x,y,*taille);
	break;
    case CANBERRA:
	*dist = R_canberra2(x,y,*taille);
	break;
    case BINARY:
	*dist = R_dist_binary2(x,y,*taille);
	break;
    }
}



/*void calculMean(double *mTraj, int *iNbInd, int *iNbTime, int *vClusterAffectation, int *iNbClusters, char *iCenterMethod,
		double *mTrajMean);
void affecteIndiv(double *mTraj, int *iNbInd, int *iNbTime, double *mTrajMean, int *iNbClusters, char *distance,
		  int *vClusterAffectation);
*/

void kml1(double *mTraj, int *pNbId, int *pNbTime,
	  double *mClustersCenter, int *pNbClusters, int *pConvergenceTime,
	  int *vClusterAffectation){
    int nbId = *pNbId, nbClusters = *pNbClusters, nbTime = *pNbTime, convergenceTime = *pConvergenceTime;

    int iter, iNbCenters, iNbId, iNbClusters, newNbClusters=0, iNbTime, indiceClusterAffect, nbNA = 0;
    double best, dist, tmp;
    int *nbIndivEachClusters=malloc(nbClusters*sizeof(int));
    Rboolean updated;

    for(iNbId = 0; iNbId < nbId; iNbId++) vClusterAffectation[iNbId] = 1;
//    Rprintf("\n\nDDD mClustersCenter=");for(int g = 0; g < nbTime*nbClusters; g++){Rprintf("%f ",mClustersCenter[g]);}
    //  Rprintf("\n DDD mAffectation=");for(int g = 0; g < nbId; g++){Rprintf("%i ",vClusterAffectation[g]);}
    for(iter = 0; iter < convergenceTime; iter++){
	updated = FALSE;
	for(iNbId = 0; iNbId < nbId; iNbId++) {
 	    // find nearest centre for each point
	    best = R_PosInf;
	    for(iNbClusters = 0; iNbClusters < nbClusters; iNbClusters++) {

		// Distance between mClustersCenter j and individual i
		dist = 0.0; nbNA = 0; tmp=0;
		for(iNbTime=0;iNbTime<nbTime;iNbTime++){
//		    Rprintf("\nAvant distance i=%i nbId=%i c=%i j=%i nbClust=%i mTraj=%f mClus=%f",i,nbId,c,j,nbClusters,mTraj[i+nbId*c],mClustersCenter[j+nbClusters*c]);
		    if(R_FINITE(mTraj[iNbId+iNbTime*nbId]) && R_FINITE(mClustersCenter[iNbClusters+iNbTime*nbClusters])){
//			Rprintf("\nXXXX Avant distance i=%i nbId=%i c=%i j=%i nbClust=%i mTraj=%f mClus=%f",i,nbId,c,j,nbClusters,mTraj[i+nbId*c],mClustersCenter[j+nbClusters*c]);
			//		Rprintf("\nDistA=%f Tmp=%f",dist,tmp);
			tmp = mTraj[iNbId+iNbTime*nbId] - mClustersCenter[iNbClusters+iNbTime*nbClusters];
//			Rprintf("\nDistB=%f Tmp=%f",dist,tmp);
			dist += (tmp * tmp);
			//		Rprintf("\nDistC=%f Tmp=%f",dist,tmp);
		    }else{
			nbNA +=1;
		    }
		}
		dist = (dist)*nbTime/(nbTime-nbNA);

		if(dist < best) {
		    best = dist;
		    newNbClusters = iNbClusters+1;
		}
	    }
	    if(vClusterAffectation[iNbId] != newNbClusters) {
		updated = TRUE;
		vClusterAffectation[iNbId] = newNbClusters;
	    }else{}

//	    Rprintf("\n\nMMM mClustersCenter=");for(int g = 0; g < nbTime*nbClusters; g++){Rprintf("%f ",mClustersCenter[g]);}
	    //    Rprintf("\n MMM mAffectation=");for(int g = 0; g < nbId; g++){Rprintf("%i ",vClusterAffectation[g]);}
//	    Rprintf("\n\nmClustersCenter=");for(int g = 0; g < nbTime*nbClusters; g++){Rprintf("%f ",mClustersCenter[g]);}
	    //    Rprintf("\nmAffectation=");for(int g = 0; g < nbId; g++){Rprintf("%i ",vClusterAffectation[g]);}
//	    Rprintf("\niter= %i max=%i i=%i",iter,convergenceTime,i);
	}

	if(!updated) break;
	// update each centre
	for(iNbCenters = 0; iNbCenters < nbClusters*nbTime; iNbCenters++) mClustersCenter[iNbCenters] = 0.0;

	for(iNbTime = 0; iNbTime < nbTime; iNbTime++) {
	    for(iNbClusters = 0; iNbClusters < nbClusters; iNbClusters++) nbIndivEachClusters[iNbClusters] = 0;
	    for(iNbId = 0; iNbId < nbId; iNbId++) {
		indiceClusterAffect = vClusterAffectation[iNbId] - 1;
		if(R_FINITE(mTraj[iNbId+iNbTime*nbId])){
		    mClustersCenter[indiceClusterAffect+iNbTime*nbClusters] += mTraj[iNbId+iNbTime*nbId];
		    nbIndivEachClusters[indiceClusterAffect]++;
		}else{}
	    }
	    for(iNbClusters = 0; iNbClusters < nbClusters; iNbClusters++){
//		Rprintf("\nTOTO");
//		Rprintf("j=%i Center=%f nbEach=%i",j,mClustersCenter[j+c*nbClusters],nbIndivEachClusters[j]);
		if(nbIndivEachClusters[iNbClusters]==0){
		    mClustersCenter[iNbClusters+iNbTime*nbClusters]=NA_REAL;
		}else{
		    mClustersCenter[iNbClusters+iNbTime*nbClusters]/=nbIndivEachClusters[iNbClusters];
		}
//		Rprintf("\n    j=%i Center=%f nbEach=%i",j,mClustersCenter[iNbClusters+iNbTime*nbClusters],nbIndivEachClusters[j]);
	    }
	}
//	Rprintf("\n\nFFF mClustersCenter=");for(int g = 0; g < nbTime*nbClusters; g++){Rprintf("%f ",mClustersCenter[g]);}
	//Rprintf("\n FFF mAffectation=");for(int g = 0; g < nbId; g++){Rprintf("%i ",vClusterAffectation[g]);}

    }
//    Rprintf("\n\nmClustersCenter=");for(int g = 0; g < nbTime*nbClusters; g++){Rprintf("%f ",mClustersCenter[g]);}
    //  Rprintf("\nmAffectation=");for(int g = 0; g < nbId; g++){Rprintf("%i ",vClusterAffectation[g]);}

    *pConvergenceTime = iter + 1;
}



/*
double euclideanNA(double *x,double *y,int *taille){
  double dist = 0.0;
  int nbNA = 0, i=0;
  double tmp=0;

  Rprintf("\n DIST 2");

  for(i=0;i<*taille;i++){
    if(R_FINITE(x[i]) && R_FINITE(y[i])){
      Rprintf("\nDistA=%f Tmp=%f",dist,tmp);
      tmp = x[i]-y[i];
      Rprintf("\nDistB=%f Tmp=%f",dist,tmp);
      dist += (tmp * tmp);
      Rprintf("\nDistC=%f Tmp=%f",dist,tmp);
    }else{
      nbNA +=1;
    }
  }
  dist = pow((dist) * *taille/(*taille-nbNA),0.5);
  return(dist);
}


double manhattanNA(double *x,double *y,int *taille){
  double dist = 0.0;
  int nbNA = 0, i=0;

  for(i=0;i<*taille;i++){
    if(R_FINITE(x[i]) && R_FINITE(y[i])){
      dist += abs(x[i]-y[i]);
    }else{
      nbNA +=1;
    }
  }
  dist = (dist)* *taille/(*taille-nbNA);
  return(dist);
}

double maximumNA(double *x,double *y,int *taille){
  double dist = 0.0,tmp = 0.0 ;
  Rboolean onlyNA = TRUE;
  int i=0 ;

  for(i=0;i<*taille;i++){
    if(R_FINITE(x[i]) && R_FINITE(y[i])){
      //		Rprintf("\nDistA=%f Tmp=%f",dist,tmp);
      tmp = abs(x[i]-y[i]);
      if(dist<tmp){dist=tmp;}else{};
      onlyNA = FALSE;
      //			Rprintf("\nDistB=%f Tmp=%f",dist,tmp);
    }else{};
  }
  if(onlyNA){
    dist = NA_REAL;
  }else{};
  return(dist);
}

double minkowskiNA(double *x,double *y,int *taille, double *power){
  double dist = 0.0;
  int nbNA = 0, i=0;

  for(i=0;i<*taille;i++){
    if(R_FINITE(x[i]) && R_FINITE(y[i])){
      dist += pow(abs(x[i]-y[i]),*power);
    }else{
      nbNA +=1;
    }
  };
  dist = pow( (dist) * *taille/(*taille-nbNA), 1/ *power);
  return(dist);
}


void distance(double *x,double *y,int *taille, double *power, double *dist){
  if(*power==2.0){
    *dist = euclideanNA(x,y,taille);
  }else{
    if(*power==1.0){
      *dist = manhattanNA(x,y,taille);
    }else{
      if(*power==R_PosInf){
	*dist = maximumNA(x,y,taille);
      }else{
        *dist = minkowskiNA(x,y,taille,power);
      }
    }
  }
}

*/
